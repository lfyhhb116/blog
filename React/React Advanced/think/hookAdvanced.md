### 类组件和函数组件区别

函数组件会捕获render内部的状态，这是两类组件最大的不同。  

[在线Demo](https://codesandbox.io/s/pjqnl16lm7?file=/src/ProfilePageFunction.js:118-122) 点击Follow，在3秒内将Dan切换为Sophie，函数组件提示为"Followed Dan"，类组件提示为"Followed Sophie"。

因为虽然props本身是不可变的，但this却是可变的，this上的数据是可以被修改的，this.props的调用每次都会获取最新的props。

函数组件在任何时机下读取到的props，都是最初捕获到的那个props。当父组件传入新的props来尝试重新渲染ProfilePage时，本质上是基于新的props入参发起了一次全新的函数调用，并不会影响上一次调用对上一个 props的捕获。

#### useEffect

每一次渲染后都执行的副作用：传入回调函数，不传依赖数组	

##### useEffect(callBack)

仅在挂载阶段执行一次的副作用：传入回调函数，且这个函数的返回值不是一个函数，同时传入一个空数组

```react
useEffect(()=>{
  // 这里是业务逻辑 
}, [])
```
仅在挂载阶段和卸载阶段执行的副作用：传入回调函数，且这个函数的返回值是一个函数，同时传入一个空数组。假如回调函数本身记为 A， 返回的函数记为 B，

那么将在挂载阶段执行 A，卸载阶段执行 B。

```react
useEffect(()=>{
  // 这里是 A 的业务逻辑
  
  // 返回一个函数记为 B
  return ()=>{
    
  }
}, [])	
```
每一次渲染都触发，且卸载阶段也会被触发的副作用：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数。
```react
useEffect(()=>{
  // 这里是 A 的业务逻辑
  
  // 返回一个函数记为 B
  return ()=>{
    
  }
})
```
根据一定的依赖条件来触发的副作用：传入回调函数(若返回值是一个函数，仍然仅影响卸载阶段对副作用的处理，此处不再赘述)，同时传入一个非空的数组

```react
useEffect(()=>{
  // 这是回调函数的业务逻辑 
  
  // 若 xxx 是一个函数，则 xxx 会在组件卸载时被触发
  return xxx
}, [num1, num2, num3])
```

若数组不为空，那么React就会在新的一次渲染后去对比前后两次的渲染，查看数组内是否有变量发生了更新(只要有一个数组元素变了，就会被认为更新发生了)，

并在有更新的前提下去触发useEffect中定义的副作用逻辑

#### React-Hooks 的使用原则 

1. 只在React函数中调用Hook
2. 不要在循环、条件或嵌套函数中调用Hook(要确保Hooks在每次渲染时都保持同样的执行顺序)

Hooks 的正常运作，在底层依赖于顺序链表。所以Hook的顺序不能变。

mountState：(首次渲染)构建链表并渲染；updateState：依次遍历链表并渲染。



